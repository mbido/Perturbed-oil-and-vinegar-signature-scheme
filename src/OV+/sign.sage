load("utils.sage")

def generate_S_mixer(field, k, t, verbose=0):
  """
  Generate a S matrix for mixing oil and vinegar polynomials.
  
  Parameters
  ----------
  field : Field
    The finite field over which the matrix is generated.
  k : integer
    The number of polynomials in the secret key.
  t : integer
    The number of fully quadratic polynomials in the secret key.
  
  Returns
  -------
  matrix
    A randomly generated oil and vinegar T matrix.
  """
  
  if verbose > 0:
    print(f"\n=======\nBegin generate_S_mixer() with k = {k}, t = {t}, verbose = {verbose}\n=======\n")
  S = block_matrix([[identity_matrix(field,t), random_matrix(field,t,k-t)],[zero_matrix(field,k-t,t),identity_matrix(field,k-t)]],subdivide=False)
  if verbose > 0:
    print(S)
  return S

def generate_T_mixer(field, k, verbose=0):
  """
  Generate a T matrix for mixing oil and vinegar variables.
  
  Parameters
  ----------
  field : Field
    The finite field over which the matrix is generated.
  k : integer
    The number of polynomials in the secret key.
  
  Returns
  -------
  matrix
    A randomly generated oil and vinegar T matrix.
  """
  if verbose > 0:
    print(f"\n=======\nBegin generate_T_mixer() with k = {k}, verbose = {verbose}\n=======\n")
  T = block_matrix([[identity_matrix(field,k), random_matrix(field,k)],[zero_matrix(field,k),identity_matrix(field,k)]],subdivide=False)
  if verbose > 0:
    print(T)
  return T

def generate_F_matrices(field, k, t, verbose=0):
  """
  Generate the list of random matrices F for the given field.

  Parameters
  ----------
  field : Field
    The finite field over which the matrices are to be generated.
  k : integer
    The number of matrices to generate and 1/2 the size of the matrices.

  Returns
  -------
  list of matrices
    The generated list of random matrices for the specified field.
    The matrices are of size 2k*2k and there top left k*k submatrix is 0.
    F_e = [0 , B1]
          [B2, B3]
  """
  if verbose > 0:
        print(f"\n=======\nBegin generate_F_matrices() with t = {t}, k = {k}, verbose = {verbose}\n=======\n")
  F = []
  for _ in range(t):
    F_e = random_matrix(field, 2*k)
    F.append(F_e)
  for _ in range(k-t):
    F_e = random_matrix(field, 2*k)
    
    if verbose > 1:
      print("F_e Before:")
      print(F_e)

    F_e[:k, :k] = matrix(field, k)

    if verbose > 1:
      print("F_e After:")
      print(f"{F_e}\n")

    F.append(F_e)
    

  if verbose > 0:
    print("F : ")
    [print(f"{F_e}\n") for F_e in F]
  return F


def generate_public_key(S, T, F, verbose=0):
  """
  Generate a public key using the private key A and the list of random matrices F.

  Parameters
  ----------
  S : matrix
    The S mixer, a k*k matrix generated by generate_S_mixer().
  T : matrix
    The T mixer, a k*k matrix generated by generate_T_mixer().
  F : list of matrices
    The list of matrices used to build the public key. Each matrix is of size 2k*2k.

  Returns
  -------
  list of matrices
    The generated public key, which is a list of k matrices of size 2k*2k.
  """
  if verbose > 0:
        print(f"\n=======\nBegin generate_public_key() with t = {t}, verbose = {verbose}\n=======\n")
  k = len(F)
  G = []
  if verbose > 0:
    print('G :')
  for i, F_e in enumerate(F):
    G_e = T.transpose() * F_e * T
    if verbose > 1:
      print(f"{T}\n\t*\n{F_e}\n\t*\n{T}\n\t=\n{G_e}\n\n")
    elif verbose > 0:
      print(f"{G_e}\n")
    G.append(G_e)

  H = []
  for i,G_e in enumerate(G):
    H_e = G_e
    for j in range(i):
      H_e += S[j][i] * G[j]
    H.append(H_e)

  if verbose > 0:
    print("H : ")
    [print(f"{H_e}\n") for H_e in H]

  return H



def create_linear_system(M, F, t, V, verbose=0):
  """
  Create the linear system for the UOV scheme.

  Parameters
  ----------
  M : vector
    The encoded message in the field (length k).
  A : matrix
    The private key. (Currently unused in the system construction.)
  F : list of matrices
    The list of random matrices used to build the system (each of size 2k x 2k).
  V : vector
    The partial signature (vinegar part), of dimension k.

  Returns
  -------
  L : matrix
    A k x k matrix used in solving for the oil part.
  r : vector
    A k-dimensional vector (right-hand side) for the system.
  """
  if verbose > 0:
        print(f"\n=======\nBegin create_linear_system() with verbose = {verbose}\n=======\n")
  k = len(V)
  field = M.base_ring()
  r = [0] * k                 # right part of the system for later
  L = [[0] * k for _ in range(k)] # left part of the system for later
  
  for e in range(k-t):
    # top right part of F[e]
    B_1 = F[e+t][:k, k:]
    # bottom left part of F[e]
    B_2 = F[e+t][k:, :k]
    # bottom right part of F[e]
    B_3 = F[e+t][k:, k:]

    # Compute quadratic form V^T * B_3 * V using dot product
    r[e] = M[e+t] - V.dot_product(B_3 * V)
    # Compute row vector V * (B_2 + B_1^T) and convert to list
    L[e] = (V * (B_2 + B_1.transpose())).list()

  if verbose > 0:
    print(matrix(field, L), '\n', vector(field, r))
  return matrix(field, L), vector(field, r)

def solve_quadratic_system(M, Y0, K, F, t, V, verbose=0):
  """
    Find a solution Z0 to the following t equations, 1 <= i <= t:
        [Y0 + KZ]T  [ Fi ] [Y0 + KZ] = Mi
        [   V   ]   [    ] [   V   ]
    Then return X := Y0 + K Z0.
  """
  # To simplify and convert Fi into a symmetric form, we need characteristic != 2 (change later)
  field = V.base_ring()
  if field.characteristic() == 2:
    print('error characteristic = 2')
    exit()
  # Setup equation in form z^T A z + B z + C = 0
  pring = PolynomialRing(field, t, names="z")
  z = matrix(pring,t,1,pring.gens())
  polys = []
  for i in range(t):
    Fi = F[i]
    oil = matrix(pring,k,1,Y0) + K * z
    vec = matrix(pring,2*k,1,vector(pring,list(oil) + list(V)))
    mi = M[i]
    polys.append((vec.transpose() * Fi * vec)[0][0] - mi)
  I = pring.ideal(polys)
  v = I.variety()
  if len(v) == 0:
    return None
  Z0 = vector(v[0][var] for var in pring.gens())
  return vector(field, list(Y0 + K * Z0) + list(V))


def sign(message, S, T, F, t, verbose=0):
  """
  Sign a message using the private key A, the vector of random matrices F
  and the OV scheme. All of that in a field \mathcal{F}_q.

  Parameters
  ----------
  message : string
    The message we want to sign.
  S : matrix
    The secret S mixer, a random matrix generated by generate_S_mixer().
  T : matrix
    The secret T mixer, a random matrix generated by generate_T_mixer().
  F : vector of matrices
    The vector of matrices used to build the public key.
  t : integer
    The number of fully quadratic forms in F.
  Returns
  -------
  vector in \mathcal{F}_q
    The signature for the message being a sage vector

  """
  if verbose > 0:
        print(f"\n=======\nBegin sign() with verbose = {verbose}\n=======\n")
  k = len(F)
  field = S.base_ring()

  M = encode_message(message, field, k)
  MU = S.transpose().inverse() * M

  if verbose > 0:
    print(f"M : {M}\n")
    
  Y = None
  while Y is None:
    V = random_vector(field, k)  # Vinegar variables (fixed)
  
    # Regenerate L and r until L is invertible
    L, r = create_linear_system(MU, F, t, V)
    while rank(L) != k-t:
      V = random_vector(field, k)
      L, r = create_linear_system(MU, F, t, V)
    #print('solve')
    Y0 = L.solve_right(r)  # Solve for oil variables
    K = L.right_kernel().basis_matrix().transpose()
    #print(f"Y0 = {Y0}\nK\n=\n{K}")
  
    Y = solve_quadratic_system(MU, Y0, K, F, t, V)
  print(V)
  print(Y)
  signature = T.inverse() * Y
  
  G = []
  print(f"X = {signature}")
  print(f"T(X) = {T * signature}")
  for i in range(k):
    G.append((T*signature) * F[i] * (T*signature))
    print(f"F[{i}](T(X)) = {(T*signature) * F[i] * (T*signature)}")
  print(S * vector(field,G))
  print(f"M = {M}")
  print(S)
  return signature
  
  if verbose > 2:
    print("L*O = r :")
    print(L)
    print("*")
    print(tuple([f"O{i}" for i in range(k)]))
    print("=")
    print(r)
    print()

  Y = vector(field, list(O) + list(V))  # Concatenate O and V

  if verbose > 1:
    print(f"Y : {Y}")

  X = vector(A.inverse() * Y) 

  if verbose > 0:
    print(f"X : {X}")

  return X

'''if True:
  k = 8
  t = 2
  q = 31
  field = GF(q)

  variables = var(" ".join(["x" + str(i) for i in range(k)]))
  print(variables)

  F = generate_F_matrices(field, k, t, 0)
  F_quad = F[:t]
  F_lin = F[t:]


  Y_list = list(variables) + [field.random_element() for _ in range(k)]
  print(Y_list)
  Y = vector(field, Y_list) # vector with half variables
  print(f"Y (over pring): {Y}")

  M = [field.random_element() for _ in range(k)] # test message


  sys_quad = [(Y * F[i] * Y - M[i]) for i in range(t)]


  sys_lin = [(Y * F[i + t] * Y - M[i + t]) for i in range(k - t)]'''

'''if False:
  k = 8
  t = 2
  q = 31
  field = GF(q)
  pring = PolynomialRing(field, "y", k)
  F = generate_F_matrices(field, k, t, 0)

  Y = vector(list(pring.gens()) + [field.random_element() for _ in range(k)])
  print(Y)

  sys = [Y*f*Y for f in F]
  V = Ideal(sys).variety()
  print(list(V))

  Y = Y([V[0][key] for key in pring.gens()])

  for f in F:
    print(Y*f*Y)

if True:
  k = 8
  t = 2
  q = 31
  field = GF(q)
  pring = PolynomialRing(field, "y", k)

  F = generate_F_matrices(field, k, t, 0)
  F_quad = F[:t]
  F_lin = F[t:]
  print(f"F_quad : {F_quad}")
  print(f"F_lin : {F_lin}")

  Y_list = list(pring.gens()) + [pring(field.random_element()) for _ in range(k)]
  Y = vector(pring, Y_list) # vector with half variables
  print(f"Y (over pring): {Y}")

  M = [field.random_element() for _ in range(k)] # test message
  print(f"M : {M}")

  sys_quad = [(Y * F[i] * Y - pring(M[i])) for i in range(t)]
  print("\nsys_quad[0]:", sys_quad[0])
  print("Type de sys_quad[0]:", type(sys_quad[0]))
  print("Parent de sys_quad[0]:", sys_quad[0].parent())

  sys_lin = [(Y * F[i + t] * Y - pring(M[i + t])) for i in range(k - t)]
  print("\nsys_lin[0]:", sys_lin[0])
  print("Type de sys_lin[0]:", type(sys_lin[0]))
  print("Parent de sys_lin[0]:", sys_lin[0].parent())


if False:
  k = 8
  t = 2
  q = 31
  field = GF(q)

  variables = var(" ".join(["x" + str(i) for i in range(k)]))
  print(variables)

  F = generate_F_matrices(field, k, t, 0)
  F_quad = F[:t]
  F_lin = F[t:]


  Y_list = list(variables) + [field.random_element() for _ in range(k)]
  print(Y_list)
  Y = vector(field, Y_list) # vector with half variables
  print(f"Y (over pring): {Y}")

  M = [field.random_element() for _ in range(k)] # test message


  sys_quad = [(Y * F[i] * Y - M[i]) for i in range(t)]


  sys_lin = [(Y * F[i + t] * Y - M[i + t]) for i in range(k - t)]


  #solve(sys_lin, pring.gens())'''